-- Status + Tags schema alignment
-- Date: 2026-02-12
-- Safe to re-run (idempotent)

begin;

-- =========================================================
-- 1) Statuses table alignment
-- =========================================================
create table if not exists public.statuses (
  id integer generated by default as identity primary key,
  code text not null,
  name text not null,
  entity_type text not null default 'all',
  color text,
  icon text,
  sort_order integer,
  is_default boolean not null default false,
  is_system_locked boolean not null default false,
  created_by uuid,
  updated_by uuid,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (code, entity_type)
);

alter table public.statuses add column if not exists code text;
alter table public.statuses add column if not exists name text;
alter table public.statuses add column if not exists entity_type text not null default 'all';
alter table public.statuses add column if not exists color text;
alter table public.statuses add column if not exists icon text;
alter table public.statuses add column if not exists sort_order integer;
alter table public.statuses add column if not exists is_default boolean not null default false;
alter table public.statuses add column if not exists is_system_locked boolean not null default false;
alter table public.statuses add column if not exists created_by uuid;
alter table public.statuses add column if not exists updated_by uuid;
alter table public.statuses add column if not exists created_at timestamptz not null default now();
alter table public.statuses add column if not exists updated_at timestamptz not null default now();

do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'statuses_created_by_fkey'
  ) then
    alter table public.statuses
      add constraint statuses_created_by_fkey
      foreign key (created_by)
      references public.profiles(id)
      on delete set null;
  end if;

  if not exists (
    select 1
    from pg_constraint
    where conname = 'statuses_updated_by_fkey'
  ) then
    alter table public.statuses
      add constraint statuses_updated_by_fkey
      foreign key (updated_by)
      references public.profiles(id)
      on delete set null;
  end if;
end $$;

create unique index if not exists idx_statuses_code_entity_type
  on public.statuses (code, entity_type);
create index if not exists idx_statuses_name on public.statuses (name);
create index if not exists idx_statuses_entity_type on public.statuses (entity_type);
create index if not exists idx_statuses_sort_order on public.statuses (sort_order);

-- =========================================================
-- 2) Status entity-type multi-select mapping (optional but recommended)
-- =========================================================
create table if not exists public.status_entity_types (
  id bigserial primary key,
  status_id integer not null references public.statuses(id) on delete cascade,
  entity_type text not null,
  created_at timestamptz not null default now(),
  unique (status_id, entity_type)
);

create index if not exists idx_status_entity_types_status_id
  on public.status_entity_types (status_id);
create index if not exists idx_status_entity_types_entity_type
  on public.status_entity_types (entity_type);

-- Backfill mapping rows from existing statuses.entity_type values.
insert into public.status_entity_types (status_id, entity_type)
select s.id, lower(trim(s.entity_type))
from public.statuses s
where coalesce(trim(s.entity_type), '') <> ''
on conflict (status_id, entity_type) do nothing;

-- =========================================================
-- 3) Tags table alignment
-- =========================================================
create table if not exists public.tags (
  id integer generated by default as identity primary key,
  name text not null unique,
  usage_count integer not null default 0,
  color text,
  description text,
  created_by uuid,
  updated_by uuid,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

alter table public.tags add column if not exists name text;
alter table public.tags add column if not exists usage_count integer not null default 0;
alter table public.tags add column if not exists color text;
alter table public.tags add column if not exists description text;
alter table public.tags add column if not exists created_by uuid;
alter table public.tags add column if not exists updated_by uuid;
alter table public.tags add column if not exists created_at timestamptz not null default now();
alter table public.tags add column if not exists updated_at timestamptz not null default now();

do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'tags_created_by_fkey'
  ) then
    alter table public.tags
      add constraint tags_created_by_fkey
      foreign key (created_by)
      references public.profiles(id)
      on delete set null;
  end if;

  if not exists (
    select 1
    from pg_constraint
    where conname = 'tags_updated_by_fkey'
  ) then
    alter table public.tags
      add constraint tags_updated_by_fkey
      foreign key (updated_by)
      references public.profiles(id)
      on delete set null;
  end if;
end $$;

create unique index if not exists idx_tags_name on public.tags (name);
create index if not exists idx_tags_usage_count on public.tags (usage_count);

-- =========================================================
-- 4) updated_at trigger helper
-- =========================================================
create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_trigger where tgname = 'trg_statuses_set_updated_at'
  ) then
    create trigger trg_statuses_set_updated_at
    before update on public.statuses
    for each row execute function public.set_updated_at();
  end if;

  if not exists (
    select 1 from pg_trigger where tgname = 'trg_tags_set_updated_at'
  ) then
    create trigger trg_tags_set_updated_at
    before update on public.tags
    for each row execute function public.set_updated_at();
  end if;
end $$;

-- =========================================================
-- 5) RLS read policies for client-side reads
-- =========================================================
alter table public.statuses enable row level security;
alter table public.status_entity_types enable row level security;
alter table public.tags enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'statuses'
      and policyname = 'statuses_select_authenticated'
  ) then
    create policy statuses_select_authenticated
      on public.statuses
      for select
      to authenticated
      using (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'status_entity_types'
      and policyname = 'status_entity_types_select_authenticated'
  ) then
    create policy status_entity_types_select_authenticated
      on public.status_entity_types
      for select
      to authenticated
      using (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'tags'
      and policyname = 'tags_select_authenticated'
  ) then
    create policy tags_select_authenticated
      on public.tags
      for select
      to authenticated
      using (true);
  end if;
end $$;

commit;
